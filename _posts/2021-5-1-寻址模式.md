---
layout: "post"
title: 寻址模式
author: LJR
category: 体系结构
tags:
    - arch
---

> 寻址模式本质上是一种机器码操作数到指令操作数的映射。

## 1. 寻址模式

指令集体系架构作为软硬件的接口，对它的理解需要从接口使用上（**汇编代码**）和实现上（**机器代码**）两个角度去理解，事实上所有抽象机制都要从这两个角度理解：

### 1.1. 寻址模式是什么意思，这里的址表示谁的地址？

+ 区分机器码操作数和指令操作数非常有必要
  + 考虑一个6502中的指令`LDA`，这条指令的意思是将一个字节的数据装载到系统累加器寄存器中。
    + 指令操作数: 单字节数据
    + 机器码操作数: 可能有多种，但可以从总体上分为访存和不访存两类
      + 不访存
        + 立即数
      + 直接内存地址
      + 间接内存地址（间接内存地址还有多种）
+ 答案：寻址模式指的是硬件**根据机器码操作数** 计算 **指令操作数地址**的方式。
  + 立即数模式 => 指令中编码立即数 $\rightarrow$ 地址即pc
  + 零页内存模式 => 指令中编码零页地址 $\rightarrow$ 地址即0x0000+指令中的编码
  + 绝对内存模式 => 指令中编码绝对内存地址 $\rightarrow$ 地址即指令中的编码
  + ...

例如

```c
LDA #10 // 立即数
LDA $00 // 0页
LDA $80, X // 索引0页
LDA ($40, x) // indexed indirect
LDA ($40), Y // indirect indexed
```

右侧给出的都是机器码操作数，通过这些机器码操作数首先获得真正的指令操作数，再执行指令操作。

### 1.2. CPU如何知道使用的是哪种寻址模式

+ 答案：通过指令**opcode**字段知道。
  + 汇编器通过编写的指令生成机器码

### 1.3. 对模拟器的编写者的影响

如果是CISC

+ 首先通过指令的opcode字段解析
  1. 寻址模式。
  2. 指令类型。
+ 然后根据机器码操作数计算指令操作数的地址。
+ 最后根据地址获取指令操作数并执行指令。

如果是RISC

+ 首先通过指令的opcode字段解析指令大类型（决定机器码操作数的布局）。
+ 根据布局获取机器码操作数
+ 由于没有复杂的寻址模式，可以直接执行

emmm，应该也要看具体的指令集体系结构的设计。

### 1.4. 为什么RISC和CISC不太一样

RISC架构中，寻址模式较少，一般只有五种。

CISC架构中，寻址模式很多，且一条指令可以对应有非常多种寻址模式，也就是多种opcode。其实是多条指令。

其实从这点也可以看出，寻址模式越少，越能高效地架构流水线。同一条指令(指令逻辑操作相同，比如都是加法，都是load到寄存器)寻址模式一多，光是指令操作数获取(**译码**)这一步差异就很大，有的直接高位补全就能获取，有的要访存，有的要访存加计算，有的计算加访存，因此延迟差异就大，如果架构流水线，流水线频率就上不去，或者根本流不起来。可能这就是所谓的不规整吧。而RISC不让译码的时候访存，要求对内存的操作必须首先`load/store`，应该也是有这方面的考虑。
