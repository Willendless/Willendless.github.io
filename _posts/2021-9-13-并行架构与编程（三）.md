---
layout: "post"
title: 并行架构与编程（三）性能优化 - 负载均衡与调度
author: LJR
category: 并行计算
---

高性能计算的目标

+ 均衡负载
+ 减少通信开销
+ 通过各种方法提高并行性，减小串行任务的占比（amdahl's law）

parallel programming rules of thumb

+ at least as much work as parallel execution capability, generally more independent work than capability
+ **"parallel slack"** = ratio of independent work to machine's parallel execution capability(**~8**)

## 1. 性能优化1: Work distribution and scheduling

> Always implement the simplest solution first, then measure performance to determine if you need to do better

### 1.1. 任务分配

+ 静态分配
  + 工作的数量和执行时间一定
  + 工作的数量一定，执行时间不同但可预测
  + 分配方式
    + blocked assignment
    + interleaved assignment
+ 半静态分配
  + 工作的执行时间在未来一段时间可预测，根据工作开销周期性调整任务的分配
+ 动态分配
  + 任务的执行时间或者任务的数量不可预测

#### 1.1.1. 动态分配1: 共享任务队列

+ one shared queue, multiple work threads
+ **tradeoff**: task granularity
  + small granularity -> better workload balance, more synchronization cost
  + large granularity -> minimize overhead of managing the assignment
  + **ideal granularity depends both on the workload and the mahcine**
+ scheduler: **long task first**

#### 1.1.2. 动态分配2: 分布式任务队列

+ set of work queues, same amount of worker threads
  + **the initial assignment of tasks is just like the static assignment**
  + on demand assignment later
+ **steal**: 若本地任务队列为空，能够从其它任务队列中获取
+ 性能特点
  + **steal阶段**存在同步开销
  + 增加locality
+ 其它设计问题
  + who to steal from?
    + Generally randomly pick one to steal from.
  + how much to steal?
  + how to detect program termination?
  + how to ensure local queue access is fast?

### 1.2. fork-join并行

![](/assets/images/pp/3-1.png)

**idea**: consider divide-and-conquer algorithms, we treat each node as a single task.

+ `cilk_spawn`: create new logical thread of control
+ `cilk_sync`: join
+ **program termination semantics**
  + **implicit `cilk_sync` at the end of every function**: returns when all calls spawned by current function have completed

![](/assets/images/pp/3-2.png)

+ **main idea**: expose independent work to the system using `cilk_spawn`

#### 1.2.1. click运行时实现: locality-aware work stealing scheduler

+ strawman
  + **launch thread** for each `cilk_spawn` using `pthread_create`
  + for each `cilk_sync` using `pthread_join`
  + problems
    + heavy cost of spawning
    + more running threads than cores
      + context switching
      + larger working set, less cache locality

real world: **thread pool + per thread work queue + steal continuation + random victim**

+ **thread pool initialization**: all threads **created when encountering the first call** to `cilk_spawn`
+ **nubmer of threads**:  equal to the number of execution contexts in the machine
+ **work**: 整个上下文，例如下图中的`child(foo())`，以及之后的`bar();`都

![](/assets/images/pp/3-3.png)

**continuation first (child stealing)**

+ put child context into work queue
+ bfs: O(N) space for spawned work

**child first (continuation stealing)**

+ put continuation context into work queue
+ **dfs**: anticipate divide and conquer parallelism, code at right generates work in parallel
+ storage space: for T threads, no more than T times that of stack storage for single threaded execution
+ **exectuion order**: same as the program with spawn removed

**other implmentation details**

+ **work queue**: lock free dequeue
+ **work stealing**: random choice of victim
  + local thred pushes/pops from the "tail"
  + remote threads steal from "heap"

**remote threads steal from top of dequeue**

+ **reduces contention** with local threads
+ **amortize steal cost**: steals work at beginning of call tree so that steal longer task, amortize steal cost with future computation
+ **maximize locality**: local thread work on local part of call tree

![](/assets/images/pp/3-4.png)

如上图，steal continuation倾向于为同一root的多个子任务生成并行执行的task（continuation随着），而steal child则继续执行root节点，直到将同一root的子任务扔到同一个queue中。
