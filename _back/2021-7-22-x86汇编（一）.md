---
layout: "post"
title: x86汇编（一）实模式汇编
category: 操作系统
author: LJR
tags:
    - x86
    - os
mathjax: true
---

> The devil is in the detail.

## 1. 编程模型

+ 寄存器
  + 通用: 
    + `AX`: Accumulator - 累加器
    + `BX`: Base Address - 基地址寄存器
    + `CX`: Counter - 计数器
    + `DX`: Data - 数据寄存器
    + `SI`: Source Index - 源索引寄存器
    + `DI`: Destination Index - 目标索引寄存器
  + 段寄存器
    + 代码段: `CS`
    + 数据段: `DS`
    + 栈段: `SS`
    + 附加段: `ES`
    + 32位和64位添加
      + `gs`
      + `fs`
  + 注意: **8086中仅`BX, SI, DI, BP`能够作为偏移地址（即`[]`中能够使用的寄存器）**
  + 注意: **索引寄存器又称为变址寄存器，常用的两个是`SI`和`DI`，INTEL-8086处理器只允许以下几种基址加变址寄存器的组合**
    + `[bx + di]`
    + `[bx + si]`
    + `[bp + di]`
    + `[bp + si]`
    + **这些组合能够用在任意有内存操作数的指令中，其它组合均非法**

## 2. 指令

### 2.1. 除法指令

根据被除数的位数不同，`div`除法指令能够被分为两类。

+ **16位二进制数除以8位二进制数**
  + **被除数**: `AX`
  + 除数: 8位的通用寄存器或者内存单元
  + **商**: `AL`
  + **余数**: `AH` 
+ **32位二进制数除以16位二进制数**
  + **被除数**: 高16位在`DX`中，低16位在`AX`中
    + **DX:AX**
  + 除数: 16位的通用寄存器或者内存单元
  + **商**: `AX`
  + **余数**: `DX`

此外还有一个有符号除法指令: `idiv`。

### 2.2. 批量传送指令

+ **原始数据串地址**: `DS:SI`
+ **目的数据串地址**: `ES:DI`
+ 传送方向
  + 由低地址向高地址传送: `cld`，清除方向位
  + 由高地址向低地址传送: `std`，设置方向位
+ `movsb`: 每次传送单个字节，并将`CX`减一，同时`DI, SI`对应递增/递减
+ `movsw`: 每次传送单个字，并将`CX`减一，同时`DI, SI`对应递增/递减
+ 注: `rep movsb`批量字节传送直到CX为0

### 2.3. loop指令

1. 将`cx`寄存器中的值减一
2. 如果`cx`寄存器不为0，转移到指定的位置处执行，否则顺序执行后面的指令

### 2.4. 符号扩展指令

+ `cbw`: 字节扩展为字
  + 将`AL`中的数符号扩展到`AX`
+ `cwd`: 字扩展为双字
  + 将`AX`中的双字符号扩展到`DX:AX`

### 2.5. 标志位

+ SF: 符号位
+ PF: 奇偶位
+ CF: 进位
+ OV: 溢出位
+ DF: 方向位

### 2.6. \$与\$\$

+ `$`: 当前行的地址
+ `$$`: 当前汇编节（段）的起始汇编地址

### 2.7. 栈指令

+ `push/pop`: （对于8086而言）操作数仅能为16位，但是必须要有关键字`word`
  + 对于`push`
    + 首先将`SP`的值减去操作数的字长
    + 然后把数据放入`SS:SP`
  + `push/pop`不影响标志位

## 3. 8086寻址方式

+ 寄存器寻址
+ 立即数寻址
+ 内存寻址: 段地址左移四位然后加上偏移地址
  + 直接寻址
    + 偏移地址为立即数或者label
  + 基址寻址
    + 偏移地址为基址寄存器**BX（默认对应DS）** 或者 **BP（默认对应SS）**
    + **基址寻址允许使用一个偏移量**，例如`mov dx, [bp-2]`
  + 变址寻址
    + 偏移地址为变址寄存器**SI** 或者 **DI**
    + 允许使用一个偏移量
  + 基址变址寻址
    + 使用一个基址寄存器和一个变址寄存器
    + 允许使用一个偏移量

```c
; 将数据串就地反向排列
string db 'abcdefghijklmnopqrstuvwxyz'

  mov bx, string
  mov si, 0
  mov di, 25
order:
  mov ah, [bx+si]
  mov al, [bx+di]
  mov [bx+si], al
  mov [bx+di], ah
  inc si
  inc di
  cmp si, di
  jl order
```

## 4. 分段机制

8086每个段的偏移地址最多16位，因此每个段最大64kB，如果段两两不相交，则有$\frac{1MB}{64kB} = 16$个段。

### 4.1. 用户程序的结构

#### 4.1.1. 定义段

+ 对于NASM编译器可以使用下面的语句定义段
  + `SECTION 段名称` 或者 `SEGMENT 段名称`
+ **段起始地址需要16字节对齐**
  + `align=16`
+ 段内标号的汇编地址的起始计算位置可以指定
  + `vstart=`: **指定段内label的起始计算地址**，且值为`vstart`的值加上偏移量。若不指定`vstart`，默认情况下，label的汇编地址从整个程序的开头开始计算
+ 段起始地址: `section.段名称.start`

#### 4.1.2. 用户程序头部信息

loader进行加载时需要从用户程序头中获取下面信息以完成加载

+ **用户程序的长度**
  + `dd`双字指定
+ **程序入口点（Entry Point）**: 第一条指令在用户程序中的位置
  + 偏移地址
  + 段地址
+ **段重定位表**: 为了重定位段，程序需要给出每个段的位置
  + 每一个表项用`dd`定义为一个双字，给出每个段的地址

## 5. 过程调用与跳转

8086共有4种调用方式

+ 近调用
  + **16位相对近调用**: 被调用的目标过程位于当前代码段内，因为段大小为64kB，因此只需要提供偏移地址
    + 例如`call near proc_1`，`near`不是必须，如果call指令中没有其它关键字，则默认为近调用
    + 机器指令操作数是一个**16位有符号数**（-32768\~32767），表示相对偏移
  + **16位间接绝对近调用**: 被调用的目标过程位于当前代码段内，但是操作数为绝对地址。
    + 操作数由**16位的通用寄存器或内存单元间接给出**
    + `call cx`
    + `call [0x3000]`
    + `call [bx]`
    + `call [bx+si+0x02]`
+ 远调用
  + **16位直接绝对远调用**: 段间调用，绝对地址
    + `call 0x2000:0x0030`
    + 处理器执行该指令需要将`CS`和`IP`均入栈
  + **16位间接绝对远调用**: 段间调用，段地址和偏移地址均保存在内存中，且相邻保存，低地址为偏移地址
    + **必须使用关键字far**
    + `proc_1 dw 0x0102, 0x2000`
    + `call far [proc_1]`

8086无条件跳转有下面几种方式

+ 短转移
  + **8位相对短转移**: 段间转移，操作数为有符号单个字节
    + 必须使用`short`关键字，操作数可以是数值或标号，在编译阶段，它们被用来计算偏移量
    + `jmp short infinite`
    + `jmp short 0x2000`
    + 注: 如果标号的偏移量
+ 近转移
  + 16位相对近转移
  + 16位间接绝对近转移
+ 远转移
  + 16位直接绝对远转移
  + 16位间接绝对远转移
