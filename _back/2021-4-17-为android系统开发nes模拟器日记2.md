---
---


类似于树莓派的CPU和GPU，nes的CPU和PPU也是一个异构系统。它们两者通过两种方式交互：

+ CPU通过IO映射寄存器和PPU通信
+ PPU通过进入V-BLANK周期向CPU发送中断信号

![ppu-arch2.png](https://i.loli.net/2021/05/17/eap5xCtLfE4qFmj.png)

首先介绍一下PPU提供给CPU控制的的内存映射寄存器。

## 1. PPU寄存器

从硬件上对于PPU而言，它自己有独立的RAM、CHR ROM以及和它们通信的总线。同时通过向CPU导出一系列内存映射寄存器让CPU能够控制PPU的行为。

![ppu-arch.png](https://i.loli.net/2021/05/17/3osrdCwe1PSMBgK.png)

CPU地址空间内存地址 **[0x2000 - 0x2007]** 位置处总共8个IO寄存器被CPU用于和PPU通信。这8个字节被镜像到CPU的 **[0x2008 - 0x3FFF]**。

这8个寄存器分别是：

+ 2个访问PPU内存映射的寄存器
  + 地址：0x2006
  + 数据：0x2007
+ 3个控制内部内存（OAM，Object Attribute Memory，保存了精灵的状态）的寄存器
  + OAM地址：0x2003
  + OAM数据：0x2004
  + 直接内存访问：
    + 0x4014：负责从CPU RAM快速拷贝256字节到OAM
+ 3个控制PPU操作的**只写**寄存器：
  + 0x2000：controller，控制PPU的通用逻辑流（使用哪个内存表，PPU是否应当中断CPU等）
  + 0x2001：mask，控制PPU渲染精灵和背景
  + 0x2005：scroll，控制PPU设置viewpoint
+ 1个负责报告PPU状态的只读寄存器
  + 0x2002：status

PPU的地址空间布局如下图所示：

![ppu.png](https://i.loli.net/2021/05/19/AmvefsoHVlkRgaO.png)

## 2. PPU执行生命周期

PPU每一帧可以渲染262个扫描线（0-240为可见扫描线，剩余的为垂直overscan）。每一个扫描线持续341个PPU时钟周期，每一个周期生成一个像素点（前256个像素点可见，剩余的为水平overscan。）NES屏幕的分辨率是320x240，因此扫描线241-262不可见。

一进入第241个扫描线，PPU就会触发VBlank NMI中断。由于241-262扫描过程中PPU不会访问内存。因此CPU此时能够随意访问PPU的内存。大多数游戏仅在这个时间周期更新屏幕的状态（即为下一帧游戏准备）。


## 3. Mirroring

PPU共使用2kB的RAM作为Name Table内存。每个Table占用1kB，共能存放2个Table。Mirroing有四种形式。不同的镜像形式下，PPU使用的“虚拟”地址和真实的“物理”内存地址的映射关系不同。

+ 水平镜像
+ 垂直镜像
+ 单屏幕镜像
+ 四屏幕镜像

## 4. CHR ROM的格式

PPU上地址空间`[0x0 .. 0x2000]`是为CHR ROM保留的，其内包含了游戏的可视化图像数据。该地址空间被分成两个bank，每个bank大小为0x1000，即4k。

可视化图像的数据由8 x 8像素被称为**tile**的图像组成，每个像素最多4种颜色（具体而言，背景最多4种颜色，`0b00`被用于表示透明像素，精灵最多3种颜色），占用两位。因此每个tile需要`8 * 8 * 2 = 128 bits = 16 bytes`。

而8kB的空间最多`8kiB / 128b = 512`个tiles，划分到两个pages/banks。

大多数NES游戏的对象由多个tile组成。tile中每个pixel使用2位进行编码，表示指向调色板颜色的索引。然而这两位并不在同一字节中。8x8的tile有8行，每一行使用两个字节(`8 * 2 / 8 = 2`)编码。第一行8个像素的低位构成了第一个字节，第二行8个像素的低位构成了第二个字节，直到第8行8个像素的低位构成第8个字节。接着是第一行8个像素的高位都成第9个字节。如下图所示：

![6502tile.png](https://i.loli.net/2021/05/21/x8sIzGwPTMHA2Bc.png)

所以可以发现第一行像素低位位于地址0x0，第一行像素高位则位于0x08.


## 调色板
